* TOC
{:toc}

# Указатели

Ещё можно почитать [тут](http://cppstudio.com/post/423/) и [тут](https://habr.com/en/company/abbyy/blog/117208/). При
самостоятельном гуглении ***не путать с владеющими, умными и прочими указателями***.

![]( https://markoutte.me/wp-content/uploads/2013/11/pointers-300x249.png )

***ТУТ БЫ ЕЩЁ ЭТО, КАРТИНОЧЕК ВСЯКИХ ТУДА СЮДА, НУ КРЧ ДА, ШОБЫ КРАСИВО БЫЛО***

## Введение

Указатель - тип, позволяющий хранить адрес другой переменной. Его размер зависит от разрядности системы, но всегда
составляет 1 **машинное слово** (“ячейка памяти”).

Вспомним, что при попытке обратиться к массиву без указания индекса мы получали какую-то бяку.

```C++
int arr[n];
cout << arr; // 0x......
```

Поздравляю, вы ~~впервые~~ встретились с указателем.

## Простейший пример

Оказывается, что можно получать адрес ячейки памяти, в которой хранится любя переменная, в любой удобный момент. Для
этого существует **оператор взятия адреса** - &.

```c++
int a;
cout << &a; // 0x......
```

Когда мы получили адрес, было бы неплохо его научиться сохранять. Вот тут и появляются указатели. Для создания указателя
пишем тип, адрес которого он будет хранить, и ставим после этого `*`.

```c++
int a;
int* a_ptr = &a;
cout << a_ptr; // 0x......
```

Обратным действием к взятию адреса будет являться **разыменование** (оператор `*`). Это получение значения по адресу.
Выглядит это таким образом:

```c++
int a = 5;
int* a_ptr = &a;
cout << *a_ptr << *(&a) << *(&a_ptr); // 5 5 0x......
```

Передача в функцию:

```c++
void swap(int* a, int* b)
{
    int c = *a;
    *a = *b;
    *b = c;
}
...
int x = 5, y = 1;
swap(x, y);
// x == 1, y == 5
```

Продемонстрированное выше применимо к любым другим типам данных.

![](http://cppstudio.com/wp-content/images/article/image28.4.png)

## Указатели и массивы

![](http://inf-w.ru/wp-content/uploads/2015/08/pointer-1.png)

Как вы могли заметить существует некоторая связь между указателями и массивами. Действительно, можно получить доступ к
элементу “альтернативным” способом.

```c++
int arr[] = {0, 1, 2, 3, 4};
int* arr_ptr = &arr[0]; //Получаем адрес первого элемента.

cout << *(arr_ptr + 2) << arr[2] << 2[arr] << *(&arr[0] + 2);
```

Заметьте, что `arr` и `&arr` будут возвращать одно и то же число, но иметь **совершенно разные типы данных** (указатель
на массив *vs* указатель на нулевой элемент массива), поэтому `arr + 2` != `&arr + 2` .

![](https://www.bestprog.net/wp-content/uploads/2017/04/02_02_04_03_03_01_.jpg)

## Передача массива в функцию

Для того, чтобы рабоать с одномерным массивом из функции, вам необходимо передавать в качестве одного из аргументов
указатель на его начало. Таким бразом, вы дублируетеуказатель на часть памяти в которой лежит массив внутрь функции и
можете работать с ним оттуда, читая его элементы и изменяя их.

```c++
void foo(int* arr, int n) {
	for (int  i = 0; i < n; ++i) {
		arr[i] *= arr[i];
	}
}

int main() {
	...
    foo(array, n);
}
```

## Арифметика указателей

Указатели можно складывать и вычитать, делить и умножать совсем нельзя. Почему?
Производить сложение и вычитание можно **только между указателем и целым числом**.
Выше вы уже видели пример, где обращение к индексу массива было сделано через сумму.

```c++
int quantity[][3] = { {1, 15, 0}, {25, 4} };
double price[][3] = { {1, 10.21, 43.01}, {3, 0.05} };
double sum = 0;
for (int i = 0; i < 6; ++i) {
    sum += (*(*(price) + i)) * (*(*(quantity) + i));
}
```

Почему синтаксис такой странный?

## Всякие штуки с new

![](https://i.stack.imgur.com/dhxMH.png)

При запуске программе выделяется несколько страниц виртуальной памяти. Разделы этих страниц делятся на **стек** и **
кучу**. Так называются две области памяти, в которых вы можете хранить свои данные.

Основные преимущества хранения данных на стеке - время чтения и записи.

Основные преимущества хранения данных на куче - возможность увеличивать объем по мере надобности(?).

### Как писать/читать с использованием стека.

Абсолютно все программы, которые вы писали использовали хранение данных на стеке. Каждый раз при обычном создании
переменной именно на стеке выделялась под нее память.

Пример:

```c++
int a, b;
double c;
string s;
a = 5;
b = a + 19;
c = a - b / 100;
s =  "https://clck.ru/8gokv";
```

Вернемся к массивам (одномерным). При создании массива на стеке выделялся монолитный кусок памяти, по которому можно
было перемещаться.

```c++
int array1[1000000000]; // Так сделать не получится.
int array2[50];
cout << array2[35];
```

### Как писать/читать с использованием кучи.

Тут все становится чуточку интереснее.

За создание переменной на куче отвечает оператор `new`. Он будет возвращать вам **указатель** на созданную переменную.

После использования все созданные переменные нужно удалить и освободить память. Это можно сделать с помощью
оператора `delete`. Так в дальнейшем эту память можно будет переиспользовать и не произойдет утечки.

Пример:

```c++
int* a = new int(5);
int* b = new int;
double* c = new double;
string* s = new string;
    
*b = *a + 19;
*c = *a - *b / 100;
*s =  "https://clck.ru/8gokv";

delete a, b, c, s;
```

Вернемся к массивам (одномерным). При создании массива на куче выделяется такой же монолитный кусок (обычно во избежание
сегментации массивы тяжелых объектов создают несколько иначе).

***ВАЖНО***: все что создавалось с помощью `new` должно быть удалено с помощью `delete`, а если использовался `new[]`,
то и удаление должно происходить через `delete[]`

```c++
int* array1 = new int[1000000000]; // А так можно.
int* array2 = new int[50];
cout  << array1[100000] << array2[35];
delete[] array1, array2;
```

## Указатели и двумерные массивы

![](https://server.179.ru/tasks/cpp/total/images/dynamic_array.png)

Если вы когда-либо захотите передать в функцию двумерный массив, то вы, скорее всего, столкнетесь с тем, что компилятор
будет упорно отказываться собирать ваше программу. Чтобы этого избежать, проще всего создавать двумерные массивы так,
как это показано ниже.

```c++
void foo (int** arr) {
	...
}

int main() {
    int** array = new int*[100]; // А так можно.
    for (int i = 0; i < 100; ++i) {
        array[i] = new int[100];
    }
    foo(array);
    
    for (int i = 0; i < 100; ++i) {
        delete[] array[i];
    }
    delete[] array;
}
```

## Ссылки

Аналогично указателям можно использовать ссылки. Ссылка позволяет создать для переменной ещё одно имя внутри программы.

```C++
int a = 5;
int& b = a;
cout << a << b; // 5 5
b++; // С b можно работать как и с обычной переменной, но отвечать она будет за ту же ячейку памяти, что и a
cout << a << b; // 6 6
```

Реализация функции `swap` через ссылки.

```c++
void swap (int& a, int& b)
{
    int c = a;
    a = b;
    b = a;
}
...
int x = 5, y = 1;
swap(x, y);
// x == 1, y == 5
```

