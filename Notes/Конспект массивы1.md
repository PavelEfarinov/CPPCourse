[TOC]

#	Одномерные массивы.

[Красивый текст с картиночками, которые мне лень вставлять.](http://www.cplusplus.com/doc/tutorial/arrays/)

Массивы в С++ позволяют хранить набор данных одного типа, например `int`.

```c++
int arr[3] = { }; // 0 0 0
int arr1[3]; // undefined
int arr2[3] = {1, 2, 3}; // 1 2 3
cout << arr[0] << arr[1] << arr[2]; // 0 0 0 
```

Индексация массива начинается с **0**. Тип данных, хранящихся в массиве должен быть **одинаков**. С каждым отдельным элементом массива можно работать как с обычной переменной.

Как и при создании любой переменной, так и при создании массива вам будет выделяться область памяти, которая будет ассоциироваться с вашим массивом. При работе с массивом адрес можно получить очень просто. Достаточно просто выполнить `cout << arr;`. Этот адрес будет иметь вид `0x...`. Это значит, что число отображается в шестнадцатеричном представлении.

 Исходя из понимания, что название массива несёт в себе что-то таинственное, ***НЕ НАДО ЕГО ТРОГАТЬ***. Для работы с массивом используйте обращение по индексу. 



##	Ввод и вывод.

К сожалению ввод и вывод массива возможен ~~только с помощью принесения в жертву Богу солнца младенца и 20 белых голубей~~ с помощью поэлементного ввода и вывода с консоли. 

```c++
int arr[n];
for(int i = 0; i < n; ++i)
{
    cin >> arr[i]; // чет записали
}

for(int i = 0; i < n; cin >> arr[i++]) 
{
    // обрабатываем значения
} // для особо жаждущих
```

С выводом все обстоит аналогично. Меняем `cin` на `cout`.



##	Перестановка элементов в обратном порядке.

Идея решения очень простая, просто идём по массиву от *0* до *n/2* индекса и меняем местами элементы с индексом *i* и *n - i - 1* (**откуда -1?**).

```C++
for(int i = 0; i <= n / 2; ++i)
{
    int c = arr[i];
    arr[i] = arr[n - i - 1];
    arr[n - i - 1] = c;
}

for(int i = 0; i <= n / 2; swap(arr[i], arr[n - i++ - 1])) { }
// Для выпендрёжников, прогугливших функцию std::swap()
```



##	Вывод массива задом-наперед без перестановки элементов в нём.

Решается ещё проще, ведь не нужно переставлять элементы. Просто меняем порядок обхода с *0, n* на *n, 0*.

```C++
for(int i = n - 1; i >= 0; --i)
{
	cout << arr[i];
}

for(int i = n - 1; i >= 0; 	cout << arr[i--]) { }
// ещё один вид извращений
```



##	Циклический сдвиг.

Необходимо сдвинуть все элементы массива на соседний индекс “слева” или “справа”.

Пример для сдвига на 1 влево.

```C++
int k = arr[0];
for(int i = 0; i < n - 1; ++i)
{
	arr[i] = arr[i + 1];
}
arr[n - 1] = k;

int k = arr[0];
for(int i = 0; i < n - 1; arr[i] = arr[i++ + 1]) { }
arr[n - 1] = k;
// следуя традиции
```

