#	Двоичная куча

[TOC]

#	Двоичное дерево

**Двоичное дерево** - дерево, где у каждого узла не более двух детей.

**Высота дерева** - количество рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её листьев

**Сбалансированное дерево** - дерево, высота которого не более чем логарифм от количества вершин этом дереве.

![Картинки по запросу "бинарное дерево"](https://miro.medium.com/max/384/1*quqRpJ_MujHELVLSPZpZ_A.png)

#	Куча

##	Определение

**Двоичная куча** или **пирамида** (англ. *Binary heap*) — такое двоичное [подвешенное дерево](https://neerc.ifmo.ru/wiki/index.php?title=Дерево,_эквивалентные_определения), для которого выполнены следующие три условия:

- Значение в любой вершине не больше (если куча для минимума), чем значения её потомков.
- На i-ом слое 2i вершин, кроме последнего. Слои нумеруются с нуля.
- Последний слой заполнен слева направо (как показано на рисунке)

![img](https://neerc.ifmo.ru/wiki/images/thumb/4/46/Min_heap.png/325px-Min_heap.png)

##	Хранение

Удобнее всего двоичную кучу хранить в виде массива $a[0..n−1]$, у которого нулевой элемент, $a[0]$ — элемент в корне, а потомками элемента $a[i]$ являются $a[2i+1]$ и $a[2i+2]$. Высота кучи определяется как высота двоичного дерева. Таким образом, высота кучи есть $O(logn)$, где n — количество узлов дерева.

![alt text](https://dementiy.gitbooks.io/algo/images/heap_as_array.png)

##	Типы куч

В основном, используются max и min кучи.

![alt text](https://dementiy.gitbooks.io/algo/images/max_min_heap.png)

Но вообще можно использовать любые операции, позволяющие строго сравнить элементы.

##	Базовые операции

Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности. Для восстановления этого свойства служат процедуры **siftDown **(просеивание вниз) и **siftUp** (просеивание вверх).

###	siftDown

Если значение измененного элемента увеличивается, то свойства кучи восстанавливаются функцией siftDown.

Работа процедуры: если i-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В противном случае меняем местами i-й элемент с наименьшим из его сыновей, после чего выполняем siftDown для этого сына. Процедура выполняется за время O(logn).

```pseudocode
function siftDown(i : int):
    while 2 * i + 1 < a.heapSize     // heapSize — количество элементов в куче
        left = 2 * i + 1             // left — левый сын
        right = 2 * i + 2            // right — правый сын
        j = left
        if right < a.heapSize and a[right] < a[left]
            j = right
        if a[i] <= a[j]
            break
        swap(a[i], a[j])
        i = j
```

![img](http://habrastorage.org/storage/habraeffect/57/6f/576f72a4e117f24a2ddb77b5cf7ecb11.png)

![img](http://habrastorage.org/storage/habraeffect/1b/2f/1b2f313a5ab4f7137bcbc72f7a29f3b6.png)

![img](http://habrastorage.org/storage/habraeffect/37/79/37798ff1492bc90950f84a9c8e4f3136.png)

### siftUp

Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются функцией siftUp.

Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно. Иначе, мы меняем местами его с отцом. После чего выполняем siftUp для этого отца. Иными словами, слишком маленький элемент всплывает наверх. Процедура выполняется за время O(logn).

```pseudocode
function siftUp(i : int):
    while a[i] < a[(i - 1) / 2]     // i  0 — мы в корне
        swap(a[i], a[(i - 1) / 2])
        i = (i - 1) / 2
```
##	Основные операции

### Извлечение минимального элемента

Выполняет извлечение минимального элемента из кучи за время O(logn). Извлечение выполняется в четыре этапа:

1. Значение корневого элемента (он и является минимальным) сохраняется для последующего возврата.
2. Последний элемент копируется в корень, после чего удаляется из кучи.
3. Вызывается siftDown для корня.
4. Сохранённый элемент возвращается.

```pseudocode
int extractMin():
    int min = a[0]
    a[0] = a[a.heapSize - 1]
    a.heapSize = a.heapSize - 1
    siftDown(0)
    return min
```


### Добавление нового элемента

Выполняет добавление элемента в кучу за время O(log⁡n). Добавление произвольного элемента в конец кучи, и восстановление свойства упорядоченности с помощью процедуры siftUp.

```pseudocode
function insert(key : int):
    a.heapSize = a.heapSize + 1
    a[a.heapSize - 1] = key
    siftUp(a.heapSize - 1)
```

###	Построение кучи

На самом деле, для построения кучи из неупорядоченного массива элементов достаточно последовательно применить `siftDown` ко всем элементам кучи, у которых есть сыновья:

```pseudocode
function buildHeap():
    for i = a.heapSize / 2 downto 0
        siftDown(i)
```

Алгоритм работает за $O(n)$. Доказательство можно смотреть вот [тут]([https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0#.D0.9F.D0.BE.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D1.83.D1.87.D0.B8_.D0.B7.D0.B0_O.28n.29](https://neerc.ifmo.ru/wiki/index.php?title=Двоичная_куча#.D0.9F.D0.BE.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D1.83.D1.87.D0.B8_.D0.B7.D0.B0_O.28n.29)).

![alt text](https://dementiy.gitbooks.io/algo/images/build_heap_1.png)

![alt text](https://dementiy.gitbooks.io/algo/images/build_heap_2.png)

![alt text](https://dementiy.gitbooks.io/algo/images/build_heap_3.png)

![alt text](https://dementiy.gitbooks.io/algo/images/build_heap_4.png)

###	Слияние двух куч

####	Наивная реализация $O(mlog(n+m))$:

Поочередно добавим все элементы из b в a. 

```pseudocode
function merge(a, b : Heap):
    while b.heapSize > 0  
        a.insert(b.extractMin())
```

####	Реализация за $O(n+m)$:

Добавим все элементы кучи b в конец массива a, после чего вызовем функцию построения кучи.

```pseudocode
function merge(a, b : Heap):
    for i = 0 to b.heapSize - 1  
        a.heapSize = a.heapSize + 1
        a[a.heapSize - 1] = b[i]
    a.buildHeap()
```

# Пирамидальная сортировка

**Сортировка кучей**, **пирамидальная сортировка** (англ. *Heapsort*) — алгоритм сортировки, использующий структуру данных [двоичная куча](https://neerc.ifmo.ru/wiki/index.php?title=Двоичная_куча). Это неустойчивый алгоритм сортировки с временем работы $O(nlog⁡n) $, где n — количество элементов для сортировки, и использующий $O(1)$ дополнительной памяти.

###	Описание алгоритма

Необходимо отсортировать массив A, размером n. Построим на базе этого массива за $O(n)$ кучу для максимума. Так как максимальный элемент находится в корне, то если поменять его местами с $A[n−1]$, он встанет на своё место. Далее вызовем процедуру `siftDown(0)`, предварительно уменьшив `heapSize` на 1. Она за $O(log⁡n) $ просеет `A[0]` на нужное место и сформирует новую кучу (так как мы уменьшили её размер, то куча располагается с `A[0]` по `A[n−2]`, а элемент `A[n−1]` находится на своём месте). Повторим эту процедуру для новой кучи, только корень будет менять местами не с `A[n−1]`, а с `A[n−2]`. Делая аналогичные действия, пока `heapSize` не станет равен 1, мы будем ставить наибольшее из оставшихся чисел в конец не отсортированной части. Очевидно, что таким образом, мы получим отсортированный массив.

###	Реализация

```pseudocode
 fun heapSort(A : list <T>):
   buildHeap(A)
   heapSize = A.size
   for i = 0 to n - 1
     swap(A[0], A[n - 1 - i])
     heapSize--
     siftDown(A, 0, heapSize)
```

###	Пример
Пусть дана последовательность из 5 элементов 3,2,4,1,5.

| Массив             | Описание шага                                                |
| ------------------ | ------------------------------------------------------------ |
| 5 3 4 1 2          | ![img](https://neerc.ifmo.ru/wiki/images/2/25/Heap1.png)Строим кучу из исходного массива |
| *Первый проход*    |                                                              |
| **2** 3 4 1 **5**  | ![img](https://neerc.ifmo.ru/wiki/images/thumb/3/35/Heap2.png/155px-Heap2.png)Меняем местами первый и последний элементы |
| **4** 3 2 1 5      | ![img](https://neerc.ifmo.ru/wiki/images/thumb/2/29/Heap3.png/155px-Heap3.png)Строим кучу из первых четырёх элементов |
| *Второй проход*    |                                                              |
| **1** 3 2 **4** 5  | Меняем местами первый и четвёртый элементы                   |
| **3** 1 2 4 5      | ![img](https://neerc.ifmo.ru/wiki/images/4/43/Heap4.png)Строим кучу из первых трёх элементов |
| *Третий проход*    |                                                              |
| **2** 1 **3** 4 5  | Меняем местами первый и третий элементы                      |
| **2** 1 3 4 5      | ![img](https://neerc.ifmo.ru/wiki/images/e/eb/Heap5.png)Строим кучу из двух элементов |
| *Четвёртый проход* |                                                              |
| **1** **2** 3 4 5  | Меняем местами первый и второй элементы                      |
| 1 2 3 4 5          | ![img](https://neerc.ifmo.ru/wiki/images/thumb/6/6d/Heap6.png/155px-Heap6.png)Массив отсортирован |