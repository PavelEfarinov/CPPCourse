[TOC]

# Сетевое взаимодействие

## Передача данных

Допустим, что вас есть программная система, состоящая не из одного процесса, а нескольких.

Пример: Одна программа считывает ввод пользователя, а вторая обеспечивает подключение к базе данных. Необходимо сделать так, что первая программа может читать и изменять данные в базе.

Как скоординировать их работу?

1. Использовать перенаправление потоков ввода/вывода.
2. Использовать запись/чтение из файла(ов).
3. ??? (я честно не смог больше придумать)

А что делать, если эти программы запущены на разных вычислительных системах? Например, разные системы в истребителе, автомобиле, космической станции.

## IP-адрес

Для передачи данных внутри компьютерной сети используются сетевые адреса. Они в свою очередь состоят из 

- MAC - адреса (физический адрес)
- IP - адреса (адрес внутри сети)

В Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети.

Про организацию подсетей, маску подсети и распределение адресов вы можете почитать самостоятельно.

Нам важно выделить то, что по IP адресу можно однозначно выделить получателя вашего сообщения.

***Важные адреса***

- 127.0.0.1 - адрес вашего компьютера
- 192.168.x.x - адрес локальной сети (таких адресов в глобальной сети быть не может)

## Порт

Мы определили, как доставить данные до необходимого компьютера, используя IP-адреса.

Одновременно у каждого запущены как минимум операционная система, браузер, пара утилит, имеющих доступ к интернету, сетевые игры и много разного другого барахла.

На компьютер пришел пакет (данные), содержащий 0x07000e6f6f62…000000A000000000

Что он значит?

Но как понять, что данные, которые были отправлены на этот компьютер предназначены именно нашей программе? 

Порт - целое неотрицательное число, означающее идентификатор процесса-получателя, которому предназначены данные.

## Socket

Сокет - программный интерфейс для обмена данными между процессами. Процессы могут находиться на одной ЭВМ или на разных.

Для подключения к сокету вам нужно знать, где он находится. За это отвечают IP-адрес и порт.

Одни из самых распространенных протоколов обмена данными являются UDP и TCP.

## Протоколы

![](https://pbs.twimg.com/media/EQXlD01WoAALZEk.jpg)

![](https://2ch.pm/diy/arch/wakaba/src/1353140774621.jpg)

![img](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse1.mm.bing.net%2Fth%3Fid%3DOIP.5Wk1OzCiiMd3d1YdjJsAOQHaEJ%26pid%3DApi&f=1)



### UDP

Как видно из мемов выше, UDP протокол не сильно заботится о том, получили вы данные или нет. Однако, протокол гарантирует, что данные, которые вы получили — валидны.

UDP использует датаграммы. Это значит, что данные, которые вы получили, будут на 100% совпадать с тем, что вы отправили. Если вы отправляете “HelloWorld”, то удаленная машина получит именно “HelloWorld”

Это позволяет использовать UDP для broadcast (одновременной передачи нескольким получателям).

Очень просто привести примеры сервисов использующих преимущественно UDP: шутеры, стриминговые сервисы и т.д.

### TCP

TCP, в противовес, является протоколом, поддерживающим соединение между двумя сокетами. Он гарантирует доставку данных и их порядок.

**ВАЖНО: ** перед началом передачи необходимо установить соединение. Это приводит к еще одной проблеме — на каждого клиента необходимо иметь отдельный TCP сокет.

Из-за того, что TCP использует поточную передачу, то при отправке “HelloWorld” вы можете получить “Hell” + “oWorld”, “H” + “elloWorld”  и т.д.

## Примеры использования

В SFML уже реализованы базовые классы для работы с сетью.

### TCP

*“Клиентская” сторона*

```c++
#include <SFML/Network.hpp>

sf::TcpSocket socket;
sf::Socket::Status status = socket.connect("192.168.0.5", 53000);
if (status != sf::Socket::Done) {
    // error...
}
```

*“Серверная“ сторона*

```c++
sf::TcpListener listener;

// bind the listener to a port
if (listener.listen(53000) != sf::Socket::Done) {
    // error...
}

// accept a new connection
sf::TcpSocket client;
if (listener.accept(client) != sf::Socket::Done) {
    // error...
}

// use "client" to communicate with the connected client,
// and continue to accept new connections with the listener
```

Все методы, которые вызываются для чтения и принятия соединения являются **блокирующими**

### UDP

Максимальный размер отправляемой датаграммы - 65536 байт

```c++
sf::UdpSocket socket;

// bind the socket to a port
if (socket.bind(54000) != sf::Socket::Done) { // sf::Socket::AnyPort
    // error...
}

char data[100] = ...;

// UDP socket:
sf::IpAddress recipient = "127.0.0.1";
unsigned short port = 54001;
if (socket.send(data, 100, recipient, port) != sf::Socket::Done) {
    // error...
}
```



```c++
sf::UdpSocket socket;

// bind the socket to a port
if (socket.bind(54001) != sf::Socket::Done) {
    // error...
}

char data[100];
std::size_t received;

// UDP socket:
sf::IpAddress sender;
unsigned short port;
if (socket.receive(data, 100, received, sender, port) != sf::Socket::Done) {
    // error...
}
std::cout << "Received " << received << " bytes from " << sender << " on port " << port << std::endl;
```

Все методы, которые вызываются для чтения являются **блокирующими**