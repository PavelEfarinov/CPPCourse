# Сортировки и асимптотика

[toc]

##	Двоичный (бинарный) поиск

###	Описание задачи

*Пусть нам дан упорядоченный массив, состоящий только из целочисленных элементов. Требуется найти позицию, на которой находится заданный элемент.*

[Еще почитать можно тут](http://shujkova.ru/sites/default/files/lec3.pdf)

[И тут]([https://neerc.ifmo.ru/wiki/index.php?title=%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA](https://neerc.ifmo.ru/wiki/index.php?title=Целочисленный_двоичный_поиск))

###	Как решать?

####	Наивно

Каждый из вас уже писал поиск элемента в массиве. Просто циклом пробегаемся по всему массиву и находим его. 

####	По-человечьи

Давайте вспомним, что массив у нас отсортированный. Возможно, это нам чем-нибудь поможет. 

Введем понятия правостороннего и левостороннего поиска.

Левосторонний - минимальный индекс элемента $$x$$ в исходном *отсортированном* массиве.

Правосторонний - максимальный индекс элемента $$x$$ в исходном *отсортированном* массиве.

Идея алгоритма заключается в том, чтобы брать элемент посередине, между границами, и сравнивать его с искомым. Если искомое больше (в случае правостороннего — не меньше), чем элемент сравнения, то сужаем область поиска так, чтобы новая левая граница была равна индексу середины предыдущей области. В противном случае присваиваем это значение правой границе. Проделываем эту процедуру до тех пор, пока правая граница больше левой более чем на 1.

####	Пример

Задан отсортированный массив [1, 2, 2, 2, 2, 3, 5, 8, 9, 11], x = 2

Правосторонний поиск двойки выдаст в результате 4, в то время как левосторонний выдаст 1 (нумерация с нуля).

Если искомого элемента в массиве нет, то правосторонний поиск выдаст минимальный элемент, больший искомого, а левосторонний наоборот, максимальный элемент, меньший искомого.

####	Псевдокод

```pseudocode
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = -1                      // l, r — левая и правая границы
    int r = len(a)    
    while l < r - 1                // Запускаем цикл
        m = (l + r) / 2            // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```

###	Вещественный бин. поиск 

Стоит заметить, что бин. поиск можно использовать не только для поиска элемента в массиве, но и для поиска ответа, подходящего под какие-либо функции, при условии, что ваша функция является монотонной (то есть для любых $$a, b: f(a) >= (<=) f(b)$$). 

Пусть вам было дано квадратное уравнение $$x^2 + sqrt(x) = 10$$ и вам было необходимо найти его решение.

Решение можно найти бин. поиском, если считать, что теперь элементы нашего массива - значения функции в точках l, r, m. При этом нам надо сужать интервал, на котором мы ищем наш ответ до тех пор, пока он не станет настолько маленьким, что погрешность его измерений станет нам не важна.

Тогда решение можно представить так:
```pseudocode
int f(int x):
	return x * x + sqrt(x) - 10
	
int binSearch(int[] a, int key): 
    int l = 0                
    int r = 1e18  
    while abs(l - r) > 1e-6:               
        m = (l + r) / 2            
        if f(m) < 0
            l = m
        else 
            r = m                  
    return r
```

###	Бин. поиск по ответу

Бинарный поиск по ответу - распространённый подход при решении задач. Часто применяется в задачах и подзадачах вида “найдите максимально возможное количество чего-либо при котором выполняются определённые условия”. Бинарный поиск по ответу в таких задачах можно применять, когда выполняются следующие условия:

- Если возможен ответ *N*, то гарантированно возможен и ответ *N*−1.
- Если невозможен ответ *N*, то гарантированно невозможен и ответ *N*+1.

В качестве примера рассмотрим следующую задачу: [CF 218 Div2 C. Гамбургеры](http://codeforces.com/contest/371/problem/C) Параметр, по которому мы выполняем бинарный поиск - количество гамбургеров, которые Поликарп может приготовить.

```pseudocode
function possible(h) :
	costB = max(0ll, (tb * h - nb) * priceB)
	costS = max(0ll, (ts * h - ns) * priceS)
	costC = max(0ll, (tc * h - nc) * priceC)
	return costB + costS + costC <= r


function maxPossible() :
	l = 0, r = 1e14
	while (l < r) :
		m = (l + r) / 2
		if (possible(m)) :
			l = m + 1
		else :
			r = m
	return l - 1   
	//l == r == первое "невозможное" количество 
}
```

##	Стек

Стек - простейшая структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека.

![](https://40pk.github.io/images/PROgrammer-Stack_1.gif)

```c++
class Stack {
public:
    void push(int newElement) {
        mArray[++mPos] = newElement;
    }
    int pop() {
        return mArray[mPos--];
    }
    bool isEmpty() {
        return mPos == -1;
    }
private:
    int mArray[100];
    int mPos = -1;
}
```

##	Очередь

Стек - простейшая структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека.

![](https://40pk.github.io/images/PROgrammer-Queue_1.gif)

```c++
class Queue {
public:
    void push(int newElement) {
        mArray[mPosBack++] = newElement;
    }
    int top() {
        return mArray[mPosTop++];
    }
    bool isEmpty() {
        return mPosTop == mPosBack;
    }
private:
    int mArray[100];
    int mPosTop = 0;
    int mPosBack = 0;
}
```

Надо обратить внимание на то, что вследствие того, что мы каждый раз при удалении элемента из очереди, сдвигаем позицию начала, данная реализация достаточно неэффективна по памяти, и, в зависимости от вашей задачи, вам стоит обдумать другой способ реализации. Рассмотрим реализацию на списке.

```c++
struct Element {
    Element() = default;
    Element(int value, Element* prev, Element* next) : value(value), prev(prev), 		     next(next) {}
    int value = 0;
    Element* prev = nullptr;
    Element* next = nullptr;
};

class Queue {
public:
    void push(int newElement) {
        if (mBack) {
            mBack->next = new Element(newElement, mBack, nullptr);
            mBack = mBack->next;
        } else {
            mBack = new Element(newElement, mBack, nullptr);
        }
        if (!mTop) {
            mTop = mBack;
        }
    }

    int top() {
        int curValue = mTop->value;
        if (mTop->next) {
            mTop->next->prev = nullptr;
        } else {
            mBack = nullptr;
        }
        Element* newTop = mTop->next ? mTop->next : nullptr;
        delete mTop;
        mTop = newTop;

        return curValue;
    }

    bool isEmpty() {
        return mTop == mBack && mTop == nullptr;
    }

private:
    Element* mTop = nullptr;
    Element* mBack = nullptr;
};
```

##	Дек (Deque)

Очень редко (но все же) встречаются задачи, где бывает полезно совместить свойства стека и очереди, то есть иметь доступ к первому с начала и первому с конца элементу. Никаких реализаций приводить не хочу, но в случае чего полезно знать, что такое существует.