* toc
  {:toc}

# Одномерные массивы.

[Красивый текст с картиночками, которые мне лень вставлять.](http://www.cplusplus.com/doc/tutorial/arrays/)

Массивы в С++ позволяют хранить набор данных одного типа, например `int`.

```c++
int arr[3] = { }; // 0 0 0
int arr1[3]; // undefined
int arr2[3] = {1, 2, 3}; // 1 2 3
cout << arr[0] << arr[1] << arr[2]; // 0 0 0 
```

Индексация массива начинается с **0**. Тип данных, хранящихся в массиве должен быть **одинаков**. С каждым отдельным
элементом массива можно работать как с обычной переменной.

Как и при создании любой переменной, так и при создании массива вам будет выделяться область памяти, которая будет
ассоциироваться с вашим массивом. При работе с массивом адрес можно получить очень просто. Достаточно просто
выполнить `cout << arr;`. Этот адрес будет иметь вид `0x...`. Это значит, что число отображается в шестнадцатеричном
представлении.

Исходя из понимания, что название массива несёт в себе что-то таинственное, ***НЕ НАДО ЕГО ТРОГАТЬ***. Для работы с
массивом используйте обращение по индексу.

## Ввод и вывод.

К сожалению ввод и вывод массива возможен ~~только с помощью принесения в жертву Богу солнца младенца и 20 белых
голубей~~ с помощью поэлементного ввода и вывода с консоли.

```c++
int arr[n];
for(int i = 0; i < n; ++i)
{
    cin >> arr[i]; // чет записали
}

for(int i = 0; i < n; cin >> arr[i++]) 
{
    // обрабатываем значения
} // для особо жаждущих
```

С выводом все обстоит аналогично. Меняем `cin` на `cout`.

## Перестановка элементов в обратном порядке.

Идея решения очень простая, просто идём по массиву от *0* до *n/2* индекса и меняем местами элементы с индексом *i* и *n
- i - 1* (**откуда -1?**).

```C++
for(int i = 0; i <= n / 2; ++i)
{
    int c = arr[i];
    arr[i] = arr[n - i - 1];
    arr[n - i - 1] = c;
}
```

## Вывод массива задом-наперед без перестановки элементов в нём.

Решается ещё проще, ведь не нужно переставлять элементы. Просто меняем порядок обхода с *0, n* на *n, 0*.

```C++
for(int i = n - 1; i >= 0; --i)
{
	cout << arr[i];
}

for(int i = n - 1; i >= 0; 	cout << arr[i--]) { }
// ещё один вид извращений
```

## Циклический сдвиг.

Необходимо сдвинуть все элементы массива на соседний индекс “слева” или “справа”.

Пример для сдвига на 1 влево.

```C++
int k = arr[0];
for(int i = 0; i < n - 1; ++i)
{
	arr[i] = arr[i + 1];
}
arr[n - 1] = k;
```

## Пообсуждаем задачи

Существует небольшой класс простых задач, связанный именно с одномерными массивами (может и с двумерными, но метод
решения аналогичный). Они скорее всего будут делиться на такие “подклассы”. Основа решения - линейный поиск. Это такой
перебор всех элементов массива фиксированное количество раз.

- Простой вывод для каждого элемента (“YES” или “NO”).
- Флаг (вывод только тогда, когда элемент был найден).
- Идём по массиву, пока не найден искомый элемент.
- Поиск по заданному свойству.
- Поиск ближайшего к заданному (например, по модулю разницы).
- Поиск второго по величине элемента за один проход.

Наибольший интерес представляют последние два.
