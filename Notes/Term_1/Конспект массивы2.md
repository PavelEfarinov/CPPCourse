* TOC
{:toc}

# Двумерные массивы.

Двумерный массив в С++ - это, по сути, массив, элементами которого являются одномерные массивы. Иными словами, массив
массивов. Такие массивы позволяют хранить матрицы из данных одного типа, например `int`.

```c++
int arr[n][m]; // в примере на картинке n == 3, m == 4
```

При этом индексация все еще идет с 0, поэтому размерность массива как по строкам, так и по столбцам все еще на 1 больше
максимального индекса в массиве.

![alt text](https://www.internet-technologies.ru/wp-content/uploads/articles/201709/java-2d-array-170105.jpg)

Мы будем считать, что первый индекс массива будет отвечать за номер рассматриваемой строки, а второй - за номер столбца.
Соответственно, `arr[1][2]` будет отвечать за третий(!) элемент второй (!) строки. (На самом деле, **это не важно**, но
для вашего удобства и отсутствия путаницы ***не стоит так делать!***)

## Ввод и вывод.

К сожалению ввод и вывод массива возможен (все еще) ~~только с помощью принесения в жертву Богу солнца младенца и 20
белых голубей~~ с помощью поэлементного ввода и вывода с консоли.

```c++
int arr[n][m];

for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        std::cin >> arr[i][j];
    }
}

for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        std::cout << arr[i][j];
    }
}
```

## Квадратная матрица. Главная и побочная диагонали.

![alt text](http://textarchive.ru/images/910/1819980/58d873a7.png)

## Получение координат по номеру формулой.

Иногда бывает очень полезно уметь получать из номера элемента в массиве его координаты.

```c++
...
int arrSize = 12;
int rowCount = 3;
int colCount = 4;
arr[rowCount][colCount];
for (int i = 0; i < arrSize; ++i) {
	std::cin >> arr[i / colCount][i % colCount];
}
```

# Простые числа.

Простое число - это число, которое делится только на само себя и на 1.

## Взаимно простые числа.

Два числа a и b являются взаимно простыми, если НОД(a, b) = 1, исходя из чего мы все уже умеем решать задачу о проверке
двух чисел на взаимную простоту!

## Разложение на простые множители.

Алгоритм работает за линейное время от величины рассматриваемого числа. Здесь представлена реализация на языке
псевдокода, чтобы вам не было слишком скучно переписывать его на С++:-)
Основная идея алгоритма заключается в том, что мы делим число на текущий множитель, пока оно делится, после чего
увеличиваем текущий множитель.

```pseudocode
 function main():
      // ввод числа n
      int curNum = n
      int probe = 2
      int primeArr[n] // массив для записи простых делителей 
      int primeCount = 0
      while (curNum ≠ 1) 
        if curNum % probe ≠ 0
            probe++
        else
            // делим пока делится
            curNum /= probe
            primeArr[primeCount++] = probe
      print(primeArr, primeCount)
```

Кроме того, есть алгоритм, работающий существенно быстрее, про который можно
почитать [тут](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B0%D0%B7%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B8%D1%82%D0%B5%D0%BB%D0%B8_(%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F))
. (в самом конце статьи)

## Проверка числа на простоту.

### Наивный алгоритм перебором.

Наивный алгоритм на то и наивен, что мы просто берем и проверяем делится ли наше число на какое-либо другое, за
исключением него самого и единицы.

```pseudocode
function main():
	// ввод числа n	
	bool isPrime = true
	for i = 2 to n
		if n mod i = 0
      		isPrime = false
      		break
	print(isPrime)
```

### Решето Эратосфена.

**Решето Эратосфена** — алгоритм нахождения
всех [простых чисел](https://neerc.ifmo.ru/wiki/index.php?title=Простые_числа) до некоторого целого числа n, который
приписывают древнегреческому математику Эратосфену Киренскому.

Для нахождения всех простых чисел не больше заданного числа *n*, следуя методу Эратосфена, нужно выполнить следующие
шаги:

1. Выписать подряд все целые числа от двух до *n* (2, 3, 4, …, *n*).
2. Пусть переменная *p* изначально равна двум — первому простому числу.
3. Вычеркнуть из списка все числа от 2*p* до *n*, делящиеся на *p* (то есть, числа 2*p*, 3*p*, 4*p*, …)
4. Найти первое не вычеркнутое число, большее чем *p*, и присвоить значению переменной *p* это число.
5. Повторять шаги 3 и 4 до тех пор, пока *p* не станет больше, чем *n*
6. Все не вычеркнутые числа в списке — простые числа.

На практике, алгоритм можно немного улучшить следующим образом. На шаге №3, числа можно вычеркивать, начиная сразу с
числа p^2^, потому что все составные числа меньше его уже будут вычеркнуты к этому времени. И, соответственно,
останавливать алгоритм можно, когда p^2^ станет больше, чем n.

```pseudocode
// возвращает только дополнительный массив
function main():
// ввод числа n
sievePrime[n] = {true} // присвоение всем элементам массива значения true
sqrtN = sqrt(n)
// выбираем следующий простой делитель
for i = 2 to sqrtN
	if sievePrime[i] = 0
		shuttle = i * i
		while shuttle ⩽ n
			sievePrime[shuttle] = false
			shuttle += i
```

