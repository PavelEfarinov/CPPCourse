* TOC
{:toc}

# Введение в ООП

## О чем вообще речь?

<img src="http://cs7003.userapi.com/v7003514/1647/qlFTgpixZtc.jpg" alt="http://cs7003.userapi.com/v7003514/1647/qlFTgpixZtc.jpg" style="zoom:75%;" />

- Обеспечение общественного порядка
- Объектно-ориентированное программирование
- Общество охраны природы
- Организация освобождения Палестины
- Отдел оперативного планирования
- Относительно ограниченная (во времени) память

---------



Объектно-ориентированная идеология разрабатывалась как попытка связать поведение сущности с её данными и спроецировать
объекты реального мира и бизнес-процессов в программный код. Задумывалось, что такой код проще читать и понимать
человеком, т. к. людям свойственно воспринимать окружающий мир как множество взаимодействующих между собой объектов,
поддающихся определенной классификации. Удалось ли идеологам достичь цели, однозначно ответить сложно

Когда вы начинаете использовать ООП, первое что вы должны сделать — это начать использовать объектное мышление. Это
самая большая проблема ООП, научиться мыслить объектно очень сложно.

Если говорить совсем простыми словами, то теперь у программиста появилась возможность создавать собственные типы данных
и использовать их как ему заблагорассудится.

Простой пример:

```C++
class Cat
{
public:
    Cat (string name)
    {
        mFurrColor = Color::Brown;
        mAge = 0;
        mWeight = 0.25;
        this -> mName = name;
    }
    void action ()
    {
        cout << mName + " кродеца\n";
	}
    
private:
    string mName;
    Color mFurrColor;
    int mAge;
    double mWeight;
    
};
...
int main ()
{
    Cat myCatGeorge("George"); // Объект класса Cat
    Cat myCatAndrew("Bread"); // Объект класса Cat
 
    myCatGeorge.action();
    myCatAndrew.action(); // Вызов метода action
}
```

## Основная информация

### Поля

Внутри вашего класса (сущности) вы можете хранить самые различные необходимые свойства. Будь то название чего-либо,
стоимость, вес, адрес, какой-то другой объект.

Такие свойства называются полями класса.

В примере сверху полями класса были цвет шерсти, имя, возраст и вес сферической кошки в вакууме.

<img src="https://cloudstatic.eva.ru/eva/300000-310000/307312/channel/15321792235094891.jpg" alt="img" style="zoom: 80%;" />

```C++
private:
    string mName;
    Color mFurrColor;
    int mAge;
    double mWeight;
```

***ВАЖНО: В примере цвет шерсти также является классом, которого в С++ не было изначально***

### Методы

<img src="https://petrochenko.ru/wp-content/uploads/2018/03/00e077028bc2ae7f11ff537b.jpg" alt="img" style="zoom: 50%;" />

Кроме свойств у объектов могут быть некоторые функции, которые с этими полями позволяют работать. В принципе метод - это
обычная функция, только с поправкой на то, что из него "видно” **все** поля класса.

```c++
void action ()
{
    cout << mName + " кродеца\n";
}
```

### Модификаторы доступа

Вашим свежим полям и методам можно задавать "область видимости". Это позволяет вам контролировать к каком контексте
будет использоваться ваш класс и сохраняет **внутреннюю логику** работы класса. Так, например, при работе с симуляцией
авиалайнера, прямой доступ на чтение и запись к характеристикам должны получать только внутренние методы (было бы очень
странно, если бы в середине симуляции у него резко поменялось количество пассажиров или мощность двигателей).

Виды модификаторов доступа:

- public - доступ к полям открыт всем, кто может создавать объекты данного класса
- protected - доступ к полям открыт только внутренним методам и наследникам этого класса
- private - доступ открыт только внутренним методам

Более подробно эта тема будет обсуждаться во втором семестре.

<img src="http://pm1.narvii.com/7182/ec7abe70c2bcc37d6cc10f63744d641a1719a59er1-1440-750v2_uhq.jpg" alt="img" style="zoom: 75%;" />



А что если читать значение, которое находится в этом поле, должны читать вообще все, а записывать туда новое, могут
только внутренние методы?

На помощь приходят особые методы - геттеры и сеттеры (обычно их делают `public`).

Их используют для валидации записываемых значений и возвращении значение необходимого поля.

```C++
public:
    string getEmail ()
    {
        return this -> mEmail;
    }
    void setEmail (string newEmail)
    {
        if (newEmail.find('@') > 0)
        {
           this -> mEmail = newEmail;
        }
    }
private:
	string mEmail;
```

#### В чем отличие класса от структуры?

В C++ в наследство от С досталось такое понятие как `struct`. Но в примере выше был использован `class`. Между ними нет
практически никакой логической разницы и структуры существуют в С++ исключительно ради обратной совместимости.
Единственная разница лишь в том, что в структурах все поля и методы являются по-умолчанию `public`, а в
классах `private`.

### Жизненный цикл

<img src="https://raw.githubusercontent.com/PavelEfarinov/CPPCourse/master/Notes/Term_1/Untitled.png" alt="image-20191215223250235" style="zoom: 33%;" />

Кроме обычных методов у класса есть еще методы жизненного цикла. В С++ их называют **конструкторами и деструкторами**.
Из названия следует, что они вызываются при создании объекта и при его "смерти”.

Конструкторы и деструкторы должны иметь имя, совпадающее с названием вашего класса.

Конструктором **по-умолчанию** называется конструктор, который не принимает никаких аргументов. Он вызывается
самостоятельно при создании объекта. Если никаких других конструкторов у класса нет, то конструктор по-умолчанию
генерируется языком автоматически.

Конструктором **копирования** называется конструктор, который принимает в качестве аргумента **ссылку** на объект того
же самого класса. Конструктор копирования генерируется языком автоматически. Оператор `=` работает аналогичным образом.

```C++
class MyClass{
public:
    MyClass ()
    {
        this -> mParameter = "default";
        cout << "constructor default\n";
    }
    
    MyClass (string someParameter)
    {
        this -> mParameter = someParameter;
        cout << "constructor "<< mParameter << '\n';
    }
    
    // Абсолютны аналог того, что написано выше, но с использованием списка инициализации
    MyClass (string someParameter): mParameter(someParameter)
    {
        cout << "constructor "<< mParameter << '\n';
    }
    
    MyClass (MyClass& someEntity)
    {
        this -> mParameter = "copied parameter";
        cout << "constructor "<< mParameter << '\n';
    }
    
    ~MyClass ()
    {
        cout << "destructor "<< mParameter << '\n';
	}
private:
    string mParameter;
};

int main()
{
	const MyClass& a = MyClass(); // аналогично записи MyClass a;
    MyClass b("not default");
    MyClass c(b); // аналогично записи MyClass c = b;
}
```

Выводом будет:

```
contructor default
constructor not default
constructor copied parameter
destructor copied parameter
destructor not default
destructor default
```

Почему порядок вызова деструктора именно такой?

## А что с указателями?

<img src="https://raw.githubusercontent.com/PavelEfarinov/CPPCourse/master/Notes/Term_1/Annotation%202019-12-15%20230019.png" alt="image-20191215225215631" style="zoom:50%;" />

На протяжении всей лекции вы, возможно, заметили запись

```c++
this -> someAttribute
object.method();
```

В С++ существует два разных оператора, позволяющих обращаться к полям и методам класса.

Оператор `.` используется, когда переменная, через которую мы пытаемся получить доступ является **ссылкой (НЕ
указателем) **на объект.

Оператор `->` используется, когда переменная, через которую мы пытаемся получить доступ является **указателем** на
объект.

Следует заметить, что  `this`, при использовании внутри класса будет подразумевать **указатель на самого себя**,
например объект, из которого вызывается метод.

<img src="https://www.meme-arsenal.com/memes/3d6ec9054f856f939065803f7f82fbef.jpg" alt="https://www.meme-arsenal.com/memes/3d6ec9054f856f939065803f7f82fbef.jpg" style="zoom:200%;" />
