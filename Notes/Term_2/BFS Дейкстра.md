#	BFS и Дейкстра

* toc
{:toc}

##	BFS

###	Описание

Пусть задан невзвешенный ориентированный граф $$G=(V,E)$$, в котором выделена исходная вершина s. Требуется найти длину кратчайшего пути (если таковой имеется) от одной заданной вершины до другой. 

Для алгоритма нам потребуются [очередь](https://neerc.ifmo.ru/wiki/index.php?title=Очередь) и множество посещенных вершин waswas, которые изначально содержат одну вершину ss. На каждом шагу алгоритм берет из начала очереди вершину v и добавляет все непосещенные смежные с v вершины в $$was$$ и в конец очереди. Если очередь пуста, то алгоритм завершает работу.

![img](https://neerc.ifmo.ru/wiki/images/thumb/2/28/Graph-BFS.gif/240px-Graph-BFS.gif)



####	Псевдокод

```pseudocode
int BFS(G: (V, E), source: int, destination: int):
    d = int[|V|]
    fill(d, ∞)
    d[source] = 0
    Q = ∅
    Q.push(source)
    while Q ≠ ∅ 
        u = Q.pop()
        for v: (u, v) in E
            if d[v] == ∞
                d[v] = d[u] + 1
                Q.push(v)
    return d[destination]
```

##	Алгоритм Дейкстры

| **Задача:**                                                  |
| ------------------------------------------------------------ |
| Для заданного взвешенного графа $G=(V,E)$ найти кратчайшие пути из заданной вершины $s$ до всех остальных вершин. Веса всех рёбер неотрицательны. |

###	Описание

![Картинки по запросу "алгоритм дейкстры"](https://cf.ppt-online.org/files/slide/x/xKmDWq8Y2bvftGZ7BUl9LVaXreRpEIQJjwk6yo/slide-2.jpg)

В [ориентированном](https://neerc.ifmo.ru/wiki/index.php?title=Ориентированный_граф) взвешенном графе $G=(V,E)$, вес рёбер которого неотрицателен и определяется весовой функцией $w:E→R$, алгоритм Дейкстры находит длины кратчайших путей из заданной вершины $s$ до всех остальных.
В алгоритме поддерживается множество вершин $U$, для которых уже вычислены длины кратчайших путей до них из $s$. На каждой итерации основного цикла выбирается вершина $u∉U$, которой на текущий момент соответствует минимальная оценка кратчайшего пути. Вершина $u$ добавляется в множество $U$ и производится релаксация всех исходящих из неё рёбер.

####	Псевдокод

```pseudocode
func dijkstra(s):
    for v∈V                    
        d[v] = ∞
        used[v] = false
    d[s] = 0
    for i∈V
        v = null
        for j∈V   // найдём вершину с минимальным расстоянием
            if !used[j] and (v == null or d[j] < d[v])
                v = j
        if d[v] == ∞
            break
        used[v] = true
        for e : исходящие из v рёбра // релаксация по всем рёбрам, исходящим из v
            if d[v] + e.len < d[e.to]
                d[e.to] = d[v] + e.len
```

####	Оценка сложности

В реализации алгоритма присутствует функция выбора вершины с минимальным значением d и релаксация по всем рёбрам для данной вершины. Асимптотика работы зависит от реализации.

Пусть n — количество вершин в графе, m — количество рёбер в графе.

|                                                              | Поиск минимума |   Релаксация   | Общее            |
| :---: | :---: | :---: | --- |
|                      Наивная реализация                      |      O(n)      |    O(1)O(1)    | O(n2+m)O(n2+m)   |
| [Двоичная куча](https://neerc.ifmo.ru/wiki/index.php?title=Двоичная_куча) |    O(logn)     | O(logn)O(log⁡n) | O(mlogn)O(mlog⁡n) |

В наивной реализации n раз осуществляем поиск вершины с минимальной величиной d среди O(n) непомеченных вершин и m раз проводим релаксацию за O(1). Для плотных графов ($m≈n^2$) данная асимптотика является оптимальной.

Используя двоичную кучу можно выполнять операции извлечения минимума и обновления элемента за O(logn). Тогда время работы алгоритма Дейкстры составит $O(nlogn+mlogn)=O(mlogn)$.

####	Пример

![Картинки по запросу "алгоритм дейкстры gif"](https://miro.medium.com/proxy/1*iYQeP4hosVTLfviZoxoQ6w.gif)
