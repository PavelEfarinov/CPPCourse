# Рекурсия

* toc
  {:toc}

## Что это такое?

### Определения

**Рекурсивная функция** - это числовая функция $$f(n)$$ от числового аргумента $n$, которая в своей записи содержит себя
же.

Рекурсия часто подразумевает под собой индукцию, то есть мы можем перейти от корректности некоторого $i$-ого утверждения
к $(i + 1)$-ому.

**Дерево рекурсивных вызовов** - дерево разбора вызовов нашей функции. (Примеры ниже)

### Примеры использования

#### Сумма ряда натуральных чисел

Заметим, что сумму ряда натуральных чисел можно представить так:

**База индукции**: сумма ряда натуральных чисел от нуля до нуля равна 0.

**Индукционный переход**: пусть сумма ряда от $0$ до $i$ мы знаем и она равна $$f(i)$$, тогда мы можем узнать сумму ряда
для $$i + 1$$. Она будет равна $f(i + 1) = f(i) + i + 1$, что в свою очередь равно $f(i) = f(i - 1) + i$, при уменьшении
нашего $i$ на один.

**Вывод**: получаем рекурсивную формулу для вычисления нашей функции:

![f={\begin{cases}f(0)=0;\\f(n)=n+f(n-1),\quad n>0\end{cases}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e54d4746ffb838d6ced9e19fb7b72563ff3285bd)

Давайте теперь напишем нашу функцию:

```c++
int sumNumbers(int n) {
    if (n == 0) {
        return 0;
    }
    return n + sumNumbers(n - 1);    
}
```

#### Вычисление n-ого числа Фибоначчи

Аналогичным образом доказывается корректность вычисления n-ого числа Фибоначчи.

**База**: для $F(0) = F(1) = 1$ утверждение выполняется.

**Индукционный переход**: для $i$-ого числа Фибоначчи, зная $i-1$ и $i - 2$ элементы мы сможем получить формулу для
вычисления $F(i) = F(i - 1) + F(i - 2)$

![F={\begin{cases}F(0)=1;\\F(1)=1;\\F(n)=F(n-1)+F(n-2),\quad n>1.\end{cases}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/25f80a8cc9fad3a17d3c84118fa356b75939d3a7)

```c++
#include <iostream>
 
int countFib(int n) {
    if (n < 2)
        return 1; 
    return countFib(n - 1) + countFib(n - 2);
}

int main() {
	std::cout << countFib(5);
}
```

Рассмотрим дерево рекурсивных вызовов для 5:

![](https://resize.yandex.net/si?key=9888595f3c2a77b44d87e184a14773ee&url=https%3A%2F%2Fprogramm.top%2Fimages%2Ffibonacci.png&width=748&height=344&typemap=gif%3Agif%3Bpng%3Apng%3B*%3Ajpeg%3B&crop=no&enlarge=0&goldenratio=yes&use-cache-headers=yes&attachment=image.png&proxy=yes)

Заметим, что в такой реализации есть один ***большой минус***! Какой?

Ответ: все значения меньшие f(4), вычисляются очень много раз, поэтому производительность такого алгоритма очень низкая.
Мы столкнулись с алгоритмом, где лучше обойтись **без рекурсии**.

#### Вычисление числа Эйлера

Некоторые рекурсивные функции бывают бесконечными. Одна из таких функций - функция, вычисляющая число $e$. Сама по себе
функция определяется таким образом:

![e = 2+\cfrac{2}{2+\cfrac{3}{3+\cfrac{4}{4+\ldots}}}\; = 2+f(2)](https://wikimedia.org/api/rest_v1/media/math/render/svg/8a4595136710a9ecdbc60ecfda9d21e412cd4bb9)

, где $f(2) = 2/(2 + f(3))$, а в общем
случае ![f(n)=\cfrac{n}{n+f(n+1)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/554177bd1465a04bf7c38cb1f4651b70ac293761)

Поскольку у этой функции нет **условия выхода из рекурсии**, она является бесконечной и будет выполняться до тех пор,
пока вы не решите ее завершить.

#### Перегрузка при написании рекурсивных функций

## Правила для проверки корректности рекурсии

1. Рекурсивная функция разрабатывается как обобщенный шаг процесса, который **вызывается в произвольных начальных
   условиях** и который приводит к **следующему шагу в некоторых новых условиях**
2. Для рекурсивного вызова необходимо определить **инварианты** – сохраняемые в процессе выполнения алгоритма условия и
   соотношения
3. **Локальными **переменными функции должны быть объявлены **все переменные**, которые **имеют отношение к протеканию
   текущего шага** процесса и к его состоянию
4. В рекурсивной функции **!!!обязательно!!!** должна быть **проверка условий завершения рекурсии, при которых следующий
   шаг процесса не выполняется**.
